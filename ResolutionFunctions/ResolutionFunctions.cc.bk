//
//  ResolutionFunctions.cc
//  
//
//  Created by Lieselotte Moreels on 25/01/16.
//
//

#include "../interface/ResolutionFunctions.h"

const std::string ResolutionFunctions::histoNames[] = {"Eparton_vs_Eparton-Ebjet", "Eparton_vs_Thparton-Thbjet", "Eparton_vs_Etaparton-Etabjet", "Eparton_vs_Phiparton-Phibjet", "Eparton_vs_Eparton-Enonbjet", "Eparton_vs_Thparton-Thnonbjet", "Eparton_vs_Etaparton-Etanonbjet", "Eparton_vs_Phiparton-Phinonbjet", "InvPtgenMu_vs_InvPtgenMu-InvPtrecMu", "InvPtgenMu_vs_ThgenMu-ThrecMu", "InvPtgenMu_vs_EtagenMu-EtarecMu", "InvPtgenMu_vs_PhigenMu-PhirecMu", "EgenEl_vs_EgenEl-ErecEl", "genEl_vs_ThgenEl-ThrecEl", "EgenEl_vs_EtagenEl-EtarecEl", "EgenEl_vs_PhigenEl-PhirecEl"};

const std::string ResolutionFunctions::histoDescription[] = {"b jet energy", "b jet theta", "b jet eta", "b jet phi", "non-b jet energy", "non-b jet theta", "non-b jet eta", "non-b jet phi", "muon inv. pt", "muon theta", "muon eta", "muon phi", "electron energy", "electron theta", "electron eta", "electron phi"};

Double_t ResolutionFunctions::dblGaus(Double_t *x, Double_t *par)
{
  Double_t norm = 1./TMath::Sqrt(2.*TMath::Pi()) * par[5]/TMath::Sqrt( pow(par[1], 2) + par[2]*pow(par[4], 2) );
  Double_t smallGaus = TMath::Exp( - TMath::Power( (x[0] - par[0])/par[1] , 2) /2. );
  Double_t broadGaus = TMath::Exp( - TMath::Power( (x[0] - par[3])/par[4] , 2) /2. );
  return norm * ( smallGaus + par[2] * broadGaus );
}

ResolutionFunctions::ResolutionFunctions(bool calculateResolutionFunctions):
muon(false), electron(false), getHistos(false), histoRes2D(), inputFileName("PlotsForResolutionFunctions.root"), nHistos(sizeof(histoNames)/sizeof(histoNames[0]))
{
  std::cout << "ResolutionFunctions::ResolutionFunctions - Initialising..." << std::endl;
  
  if (calculateResolutionFunctions)
  {
    bookHistograms();
  }
  else
  {
    std::cout << "Using resolution functions from file..." << std::endl;
  }
}

ResolutionFunctions::~ResolutionFunctions()
{
  /// Clean output files, etc.
}

std::string ResolutionFunctions::toStr(int number)
{
  std::ostringstream convert;
  convert.clear();
  convert << number;
  return convert.str();
}

void ResolutionFunctions::bookHistograms()
{
  std::cout << "ResolutionFunctions::bookHistograms - Initialising..." << std::endl;
  
  /// Energy, pT
  histoRes2D["Eparton_vs_Enonbjet"] = new TH2F("Eparton_vs_Enonbjet","Eparton_vs_Enonbjet", 50, 0, 400, 50, 0, 400);
  histoRes2D["Eparton_vs_Eparton-Enonbjet"] = new TH2F("Eparton_vs_Eparton-Enonbjet","Eparton_vs_Eparton-Enonbjet", 4, 0, 250, 100, -100, 100);
  histoRes2D["Eparton_vs_Ebjet"] = new TH2F("Eparton_vs_Ebjet","Eparton_vs_Ebjet", 50, 0, 400, 50, 0, 400);
  histoRes2D["Eparton_vs_Eparton-Ebjet"] = new TH2F("Eparton_vs_Eparton-Ebjet","Eparton_vs_Eparton-Ebjet", 4, 0, 300, 100, -100, 100);
  histoRes2D["EgenEl_vs_ErecEl"] = new TH2F("EgenEl_vs_ErecEl","EgenEl_vs_ErecEl", 50, 0, 400, 50, 0, 400);
  histoRes2D["EgenEl_vs_EgenEl-ErecEl"] = new TH2F("EgenEl_vs_EgenEl-ErecEl","EgenEl_vs_EgenEl-ErecEl", 50, 0, 400, 100, -50, 50);
  histoRes2D["InvPtgenMu_vs_InvPtrecMu"] = new TH2F("InvPtgenMu_vs_InvPtrecMu","InvPtgenMu_vs_InvPtrecMu", 50, 0, 0.05, 50, 0, 0.05);
  histoRes2D["InvPtgenMu_vs_InvPtgenMu-InvPtrecMu"] = new TH2F("InvPtgenMu_vs_InvPtgenMu-InvPtrecMu","InvPtgenMu_vs_InvPtgenMu-InvPtrecMu", 5, 0.002, 0.04, 100, -0.003, 0.003);
  
  /// Theta
  histoRes2D["Thparton_vs_Thnonbjet"] = new TH2F("Thparton_vs_Thnonbjet","Thparton_vs_Thnonbjet", 60, 0, 3.15, 60, 0, 3.15);
  histoRes2D["Thparton_vs_Thparton-Thnonbjet"] = new TH2F("Thparton_vs_Thparton-Thnonbjet","Thparton_vs_Thparton-Thnonbjet", 5, 0.1, 3.0, 60, -0.15, 0.15);
  histoRes2D["Thparton_vs_Thbjet"] = new TH2F("Thparton_vs_Thbjet","Thparton_vs_Thbjet", 60, 0, 3.15, 60, 0, 3.15);
  histoRes2D["Thparton_vs_Thparton-Thbjet"] = new TH2F("Thparton_vs_Thparton-Thbjet","Thparton_vs_Thparton-Thbjet", 5, 0.1, 3.0, 60, -0.15, 0.15);
  histoRes2D["ThgenEl_vs_ThrecEl"] = new TH2F("ThgenEl_vs_ThrecEl","ThgenEl_vs_ThrecEl", 60, 0, 3.15, 60, 0, 3.15);
  histoRes2D["ThgenEl_vs_ThgenEl-ThrecEl"] = new TH2F("ThgenEl_vs_ThgenEl-ThrecEl","ThgenEl_vs_ThgenEl-ThrecEl", 5, 0.2, 3.0, 60, -0.05, 0.05);
  histoRes2D["ThgenMu_vs_ThrecMu"] = new TH2F("ThgenMu_vs_ThrecMu","ThgenMu_vs_ThrecMu", 60, 0, 3.15, 60, 0, 3.15);
  histoRes2D["ThgenMu_vs_ThgenMu-ThrecMu"] = new TH2F("ThgenMu_vs_ThgenMu-ThrecMu","ThgenMu_vs_ThgenMu-ThrecMu", 5, 0.2, 3.0, 60, -0.05, 0.05);
  
  /// Energy, pT vs theta
  histoRes2D["Eparton_vs_Thnonbjet"] = new TH2F("Eparton_vs_Thnonbjet","Eparton_vs_Thnonbjet", 50, 0, 400, 60, 0, 3.15);
  histoRes2D["Eparton_vs_Thparton-Thnonbjet"] = new TH2F("Eparton_vs_Thparton-Thnonbjet","Eparton_vs_Thparton-Thnonbjet", 4, 0, 250, 100, -0.15, 0.15);
  histoRes2D["Eparton_vs_Thbjet"] = new TH2F("Eparton_vs_Thbjet","Eparton_vs_Thbjet", 50, 0, 400, 60, 0, 3.15);
  histoRes2D["Eparton_vs_Thparton-Thbjet"] = new TH2F("Eparton_vs_Thparton-Thbjet","Eparton_vs_Thparton-Thbjet", 4, 0, 300, 100, -0.15, 0.15);
  histoRes2D["EgenEl_vs_ThrecEl"] = new TH2F("EgenEl_vs_ThrecEl","EgenEl_vs_ThrecEl", 50, 0, 400, 60, 0, 3.15);
  histoRes2D["EgenEl_vs_ThgenEl-ThrecEl"] = new TH2F("EgenEl_vs_ThgenEl-ThrecEl","EgenEl_vs_ThgenEl-ThrecEl", 5, 0, 400, 100, -0.05, 0.05);
  histoRes2D["InvPtgenMu_vs_ThrecMu"] = new TH2F("InvPtgenMu_vs_ThrecMu","InvPtgenMu_vs_ThrecMu", 50, 0, 0.05, 60, 0, 3.15);
  histoRes2D["InvPtgenMu_vs_ThgenMu-ThrecMu"] = new TH2F("InvPtgenMu_vs_ThgenMu-ThrecMu","InvPtgenMu_vs_ThgenMu-ThrecMu", 5, 0.002, 0.04, 100, -0.002, 0.002);
  
  /// Eta
  histoRes2D["Etaparton_vs_Etanonbjet"] = new TH2F("Etaparton_vs_Etanonbjet","Etaparton_vs_Etanonbjet", 60, 0, 2.5, 60, 0, 2.5);
  histoRes2D["Etaparton_vs_Etaparton-Etanonbjet"] = new TH2F("Etaparton_vs_Etaparton-Etanonbjet","Etaparton_vs_Etaparton-Etanonbjet", 5, 0.1, 2.4, 60, -0.15, 0.15);
  histoRes2D["Etaparton_vs_Etabjet"] = new TH2F("Etaparton_vs_Etabjet","Etaparton_vs_Etabjet", 60, 0, 2.5, 60, 0, 2.5);
  histoRes2D["Etaparton_vs_Etaparton-Etabjet"] = new TH2F("Etaparton_vs_Etaparton-Etabjet","Etaparton_vs_Etaparton-Etabjet", 5, 0.1, 2.4, 60, -0.15, 0.15);
  histoRes2D["EtagenEl_vs_EtarecEl"] = new TH2F("EtagenEl_vs_EtarecEl","EtagenEl_vs_EtarecEl", 60, 0, 2.5, 60, 0, 2.5);
  histoRes2D["EtagenEl_vs_EtagenEl-EtarecEl"] = new TH2F("EtagenEl_vs_EtagenEl-EtarecEl","EtagenEl_vs_EtagenEl-EtarecEl", 5, 0.1, 2.1, 60, -0.05, 0.05);
  histoRes2D["EtagenMu_vs_EtarecMu"] = new TH2F("EtagenMu_vs_EtarecMu","EtagenMu_vs_EtarecMu", 60, 0, 2.5, 60, 0, 2.5);
  histoRes2D["EtagenMu_vs_EtagenMu-EtarecMu"] = new TH2F("EtagenMu_vs_EtagenMu-EtarecMu","EtagenMu_vs_EtagenMu-EtarecMu", 5, 0.1, 2.1, 60, -0.05, 0.05);
  
  /// Energy, pT vs eta
  histoRes2D["Eparton_vs_Etanonbjet"] = new TH2F("Eparton_vs_Etanonbjet","Eparton_vs_Etanonbjet", 50, 0, 400, 60, 0, 2.5);
  histoRes2D["Eparton_vs_Etaparton-Etanonbjet"] = new TH2F("Eparton_vs_Etaparton-Etanonbjet","Eparton_vs_Etaparton-Etanonbjet", 4, 0, 250, 100, -0.15, 0.15);
  histoRes2D["Eparton_vs_Etabjet"] = new TH2F("Eparton_vs_Etabjet","Eparton_vs_Etabjet", 50, 0, 400, 60, 0, 2.5);
  histoRes2D["Eparton_vs_Etaparton-Etabjet"] = new TH2F("Eparton_vs_Etaparton-Etabjet","Eparton_vs_Etaparton-Etabjet", 4, 0, 300, 100, -0.15, 0.15);
  histoRes2D["EgenEl_vs_EtarecEl"] = new TH2F("EgenEl_vs_EtarecEl","EgenEl_vs_EtarecEl", 50, 0, 400, 60, 0, 2.5);
  histoRes2D["EgenEl_vs_EtagenEl-EtarecEl"] = new TH2F("EgenEl_vs_EtagenEl-EtarecEl","EgenEl_vs_EtagenEl-EtarecEl", 5, 0, 400, 100, -0.05, 0.05);
  histoRes2D["InvPtgenMu_vs_EtarecMu"] = new TH2F("InvPtgenMu_vs_EtarecMu","InvPtgenMu_vs_EtarecMu", 50, 0, 0.05, 60, 0, 2.5);
  histoRes2D["InvPtgenMu_vs_EtagenMu-EtarecMu"] = new TH2F("InvPtgenMu_vs_EtagenMu-EtarecMu","InvPtgenMu_vs_EtagenMu-EtarecMu", 5, 0.002, 0.04, 100, -0.05, 0.05);
  
  /// Phi
  histoRes2D["Phiparton_vs_Phinonbjet"] = new TH2F("Phiparton_vs_Phinonbjet","Phiparton_vs_Phinonbjet", 120, -3.2, 3.2, 120, -3.2, 3.2);
  histoRes2D["Phiparton_vs_Phiparton-Phinonbjet"] = new TH2F("Phiparton_vs_Phiparton-Phinonbjet","Phiparton_vs_Phiparton-Phinonbjet", 5, -3.2, 3.2, 120, -0.3, 0.3);
  histoRes2D["Phiparton_vs_Phibjet"] = new TH2F("Phiparton_vs_Phibjet","Phiparton_vs_Phibjet", 120, -3.2, 3.2, 120, -3.2, 3.2);
  histoRes2D["Phiparton_vs_Phiparton-Phibjet"] = new TH2F("Phiparton_vs_Phiparton-Phibjet","Phiparton_vs_Phiparton-Phibjet", 5, -3.2, 3.2, 120, -0.3, 0.3);
  histoRes2D["PhigenEl_vs_PhirecEl"] = new TH2F("PhigenEl_vs_PhirecEl","PhigenEl_vs_PhirecEl", 120, -3.2, 3.2, 120, -3.2, 3.2);
  histoRes2D["PhigenEl_vs_PhigenEl-PhirecEl"] = new TH2F("PhigenEl_vs_PhigenEl-PhirecEl","PhigenEl_vs_PhigenEl-PhirecEl", 5, -3.2, 3.2, 120, -0.05, 0.05);
  histoRes2D["PhigenMu_vs_PhirecMu"] = new TH2F("PhigenMu_vs_PhirecMu","PhigenMu_vs_PhirecMu", 120, -3.2, 3.2, 120, -3.2, 3.2);
  histoRes2D["PhigenMu_vs_PhigenMu-PhirecMu"] = new TH2F("PhigenMu_vs_PhigenMu-PhirecMu","PhigenMu_vs_PhigenMu-PhirecMu", 5, -3.2, 3.2, 120, -0.05, 0.05);
  
  /// Energy, pT vs phi
  histoRes2D["Eparton_vs_Phinonbjet"] = new TH2F("Eparton_vs_Phinonbjet","Eparton_vs_Phinonbjet", 50, 0, 400, 120, -3.2, 3.2);
  histoRes2D["Eparton_vs_Phiparton-Phinonbjet"] = new TH2F("Eparton_vs_Phiparton-Phinonbjet","Eparton_vs_Phiparton-Phinonbjet", 5, 0, 250, 100, -0.3, 0.3);
  histoRes2D["Eparton_vs_Phibjet"] = new TH2F("Eparton_vs_Phibjet","Eparton_vs_Phibjet", 50, 0, 400, 120, -3.2, 3.2);
  histoRes2D["Eparton_vs_Phiparton-Phibjet"] = new TH2F("Eparton_vs_Phiparton-Phibjet","Eparton_vs_Phiparton-Phibjet", 5, 0, 300, 100, -0.2, 0.2);
  histoRes2D["EgenEl_vs_PhirecEl"] = new TH2F("EgenEl_vs_PhirecEl","EgenEl_vs_PhirecEl", 50, 0, 400, 120, -3.2, 3.2);
  histoRes2D["EgenEl_vs_PhigenEl-PhirecEl"] = new TH2F("EgenEl_vs_PhigenEl-PhirecEl","EgenEl_vs_PhigenEl-PhirecEl", 5, 0, 400, 100, -0.05, 0.05);
  histoRes2D["InvPtgenMu_vs_PhirecMu"] = new TH2F("InvPtgenMu_vs_PhirecMu","InvPtgenMu_vs_PhirecMu", 50, 0, 0.05, 120, -3.2, 3.2);
  histoRes2D["InvPtgenMu_vs_PhigenMu-PhirecMu"] = new TH2F("InvPtgenMu_vs_PhigenMu-PhirecMu","InvPtgenMu_vs_PhigenMu-PhirecMu", 5, 0.002, 0.04, 100, -0.002, 0.002);
  
  std::cout << "                                  - Histograms booked" << std::endl;
}

void ResolutionFunctions::fillJets(std::vector<TLorentzVector> &parton, std::vector<TLorentzVector> &jet)
{
  /// 0,1: light jets from W; 2: hadronic b jet; 3: leptonic b jet
  
  /// Energy
  histoRes2D["Eparton_vs_Enonbjet"]->Fill(parton[0].E(),jet[0].E());
  histoRes2D["Eparton_vs_Eparton-Enonbjet"]->Fill(parton[0].E(),parton[0].E()-jet[0].E());
  histoRes2D["Eparton_vs_Enonbjet"]->Fill(parton[1].E(),jet[1].E());
  histoRes2D["Eparton_vs_Eparton-Enonbjet"]->Fill(parton[1].E(),parton[1].E()-jet[1].E());
  histoRes2D["Eparton_vs_Ebjet"]->Fill(parton[2].E(),jet[2].E());
  histoRes2D["Eparton_vs_Eparton-Ebjet"]->Fill(parton[2].E(),parton[2].E()-jet[2].E());
  histoRes2D["Eparton_vs_Ebjet"]->Fill(parton[3].E(),jet[3].E());
  histoRes2D["Eparton_vs_Eparton-Ebjet"]->Fill(parton[3].E(),parton[3].E()-jet[3].E());
  
  /// Theta
  histoRes2D["Thparton_vs_Thnonbjet"]->Fill(parton[0].Theta(),jet[0].Theta());
  histoRes2D["Thparton_vs_Thparton-Thnonbjet"]->Fill(parton[0].Theta(),parton[0].Theta()-jet[0].Theta());
  histoRes2D["Thparton_vs_Thnonbjet"]->Fill(parton[1].Theta(),jet[1].Theta());
  histoRes2D["Thparton_vs_Thparton-Thnonbjet"]->Fill(parton[1].Theta(),parton[1].Theta()-jet[1].Theta());
  histoRes2D["Thparton_vs_Thbjet"]->Fill(parton[2].Theta(),jet[2].Theta());
  histoRes2D["Thparton_vs_Thparton-Thbjet"]->Fill(parton[2].Theta(),parton[2].Theta()-jet[2].Theta());
  histoRes2D["Thparton_vs_Thbjet"]->Fill(parton[3].Theta(),jet[3].Theta());
  histoRes2D["Thparton_vs_Thparton-Thbjet"]->Fill(parton[3].Theta(),parton[3].Theta()-jet[3].Theta());
  histoRes2D["Eparton_vs_Thnonbjet"]->Fill(parton[0].E(),jet[0].Theta());
  histoRes2D["Eparton_vs_Thparton-Thnonbjet"]->Fill(parton[0].E(),parton[0].Theta()-jet[0].Theta());
  histoRes2D["Eparton_vs_Thnonbjet"]->Fill(parton[1].E(),jet[1].Theta());
  histoRes2D["Eparton_vs_Thparton-Thnonbjet"]->Fill(parton[1].E(),parton[1].Theta()-jet[1].Theta());
  histoRes2D["Eparton_vs_Thbjet"]->Fill(parton[2].E(),jet[2].Theta());
  histoRes2D["Eparton_vs_Thparton-Thbjet"]->Fill(parton[2].E(),parton[2].Theta()-jet[2].Theta());
  histoRes2D["Eparton_vs_Thbjet"]->Fill(parton[3].E(),jet[3].Theta());
  histoRes2D["Eparton_vs_Thparton-Thbjet"]->Fill(parton[3].E(),parton[3].Theta()-jet[3].Theta());

  /// Eta
  histoRes2D["Etaparton_vs_Etanonbjet"]->Fill(parton[0].Eta(),jet[0].Eta());
  histoRes2D["Etaparton_vs_Etaparton-Etanonbjet"]->Fill(parton[0].Eta(),parton[0].Eta()-jet[0].Eta());
  histoRes2D["Etaparton_vs_Etanonbjet"]->Fill(parton[1].Eta(),jet[1].Eta());
  histoRes2D["Etaparton_vs_Etaparton-Etanonbjet"]->Fill(parton[1].Eta(),parton[1].Eta()-jet[1].Eta());
  histoRes2D["Etaparton_vs_Etabjet"]->Fill(parton[2].Eta(),jet[2].Eta());
  histoRes2D["Etaparton_vs_Etaparton-Etabjet"]->Fill(parton[2].Eta(),parton[2].Eta()-jet[2].Eta());
  histoRes2D["Etaparton_vs_Etabjet"]->Fill(parton[3].Eta(),jet[3].Eta());
  histoRes2D["Etaparton_vs_Etaparton-Etabjet"]->Fill(parton[3].Eta(),parton[3].Eta()-jet[3].Eta());
  histoRes2D["Eparton_vs_Etanonbjet"]->Fill(parton[0].E(),jet[0].Eta());
  histoRes2D["Eparton_vs_Etaparton-Etanonbjet"]->Fill(parton[0].E(),parton[0].Eta()-jet[0].Eta());
  histoRes2D["Eparton_vs_Etanonbjet"]->Fill(parton[1].E(),jet[1].Eta());
  histoRes2D["Eparton_vs_Etaparton-Etanonbjet"]->Fill(parton[1].E(),parton[1].Eta()-jet[1].Eta());
  histoRes2D["Eparton_vs_Etabjet"]->Fill(parton[2].E(),jet[2].Eta());
  histoRes2D["Eparton_vs_Etaparton-Etabjet"]->Fill(parton[2].E(),parton[2].Eta()-jet[2].Eta());
  histoRes2D["Eparton_vs_Etabjet"]->Fill(parton[3].E(),jet[3].Eta());
  histoRes2D["Eparton_vs_Etaparton-Etabjet"]->Fill(parton[3].E(),parton[3].Eta()-jet[3].Eta());

  /// Phi
  histoRes2D["Phiparton_vs_Phinonbjet"]->Fill(parton[0].Phi(),jet[0].Phi());
  histoRes2D["Phiparton_vs_Phinonbjet"]->Fill(parton[1].Phi(),jet[1].Phi());
  histoRes2D["Eparton_vs_Phinonbjet"]->Fill(parton[0].E(),jet[0].Phi());
  histoRes2D["Eparton_vs_Phinonbjet"]->Fill(parton[1].E(),jet[1].Phi());
  float DeltaPhi_nonbjet1 = ROOT::Math::VectorUtil::DeltaPhi(parton[0],jet[0]);
  histoRes2D["Phiparton_vs_Phiparton-Phinonbjet"]->Fill(parton[0].Phi(),DeltaPhi_nonbjet1);
  histoRes2D["Eparton_vs_Phiparton-Phinonbjet"]->Fill(parton[0].E(),DeltaPhi_nonbjet1);
  float DeltaPhi_nonbjet2 = ROOT::Math::VectorUtil::DeltaPhi(parton[1],jet[1]);
  histoRes2D["Phiparton_vs_Phiparton-Phinonbjet"]->Fill(parton[1].Phi(),DeltaPhi_nonbjet2);
  histoRes2D["Eparton_vs_Phiparton-Phinonbjet"]->Fill(parton[1].E(),DeltaPhi_nonbjet2);

  histoRes2D["Phiparton_vs_Phibjet"]->Fill(parton[2].Phi(),jet[2].Phi());
  histoRes2D["Phiparton_vs_Phibjet"]->Fill(parton[3].Phi(),jet[3].Phi());
  histoRes2D["Eparton_vs_Phibjet"]->Fill(parton[2].E(),jet[2].Phi());
  histoRes2D["Eparton_vs_Phibjet"]->Fill(parton[3].E(),jet[3].Phi());
  float DeltaPhi_bjet1 = ROOT::Math::VectorUtil::DeltaPhi(parton[2],jet[3]);
  histoRes2D["Phiparton_vs_Phiparton-Phibjet"]->Fill(parton[2].Phi(),DeltaPhi_bjet1);
  histoRes2D["Eparton_vs_Phiparton-Phibjet"]->Fill(parton[2].E(),DeltaPhi_bjet1);
  float DeltaPhi_bjet2 = ROOT::Math::VectorUtil::DeltaPhi(parton[3],jet[3]);
  histoRes2D["Phiparton_vs_Phiparton-Phibjet"]->Fill(parton[3].Phi(),DeltaPhi_bjet2);
  histoRes2D["Eparton_vs_Phiparton-Phibjet"]->Fill(parton[3].E(),DeltaPhi_bjet2);
  
}

void ResolutionFunctions::fillMuon(TLorentzVector genMu, TLorentzVector recMu)
{
  
  muon = true;
  
  float InvPtgenMu = 1./genMu.Pt();
  float InvPtrecMu = 1./recMu.Pt();
  histoRes2D["InvPtgenMu_vs_InvPtrecMu"]->Fill(InvPtgenMu,InvPtrecMu);
  histoRes2D["InvPtgenMu_vs_InvPtgenMu-InvPtrecMu"]->Fill(InvPtgenMu,InvPtgenMu-InvPtrecMu);
  
  histoRes2D["ThgenMu_vs_ThrecMu"]->Fill(genMu.Theta(),recMu.Theta());
  histoRes2D["ThgenMu_vs_ThgenMu-ThrecMu"]->Fill(genMu.Theta(),genMu.Theta()-recMu.Theta());
  histoRes2D["InvPtgenMu_vs_ThrecMu"]->Fill(1./genMu.Pt(),recMu.Theta());
  histoRes2D["InvPtgenMu_vs_ThgenMu-ThrecMu"]->Fill(1./genMu.Pt(),genMu.Theta()-recMu.Theta());
  
  histoRes2D["EtagenMu_vs_EtarecMu"]->Fill(genMu.Eta(),recMu.Eta());
  histoRes2D["EtagenMu_vs_EtagenMu-EtarecMu"]->Fill(genMu.Eta(),genMu.Eta()-recMu.Eta());
  histoRes2D["InvPtgenMu_vs_EtarecMu"]->Fill(1./genMu.Pt(),recMu.Eta());
  histoRes2D["InvPtgenMu_vs_EtagenMu-EtarecMu"]->Fill(1./genMu.Pt(),genMu.Eta()-recMu.Eta());
  
  histoRes2D["PhigenMu_vs_PhirecMu"]->Fill(genMu.Phi(),recMu.Phi());
  histoRes2D["InvPtgenMu_vs_PhirecMu"]->Fill(1./genMu.Pt(),recMu.Phi());
  float DeltaPhi = ROOT::Math::VectorUtil::DeltaPhi(genMu,recMu);
  histoRes2D["PhigenMu_vs_PhigenMu-PhirecMu"]->Fill(genMu.Phi(),DeltaPhi);
  histoRes2D["InvPtgenMu_vs_PhigenMu-PhirecMu"]->Fill(1./genMu.Pt(),DeltaPhi);
  
}

void ResolutionFunctions::fillElectron(TLorentzVector genEl, TLorentzVector recEl)
{
  
  electron = true;
  
  histoRes2D["EgenEl_vs_ErecEl"]->Fill(genEl.E(),recEl.E());
  histoRes2D["EgenEl_vs_EgenEl-ErecEl"]->Fill(genEl.E(),genEl.E()-recEl.E());
  
  histoRes2D["ThgenEl_vs_ThrecEl"]->Fill(genEl.Theta(),recEl.Theta());
  histoRes2D["ThgenEl_vs_ThgenEl-ThrecEl"]->Fill(genEl.Theta(),genEl.Theta()-recEl.Theta());
  histoRes2D["EgenEl_vs_ThrecEl"]->Fill(genEl.E(),recEl.Theta());
  histoRes2D["EgenEl_vs_ThgenEl-ThrecEl"]->Fill(genEl.E(),genEl.Theta()-recEl.Theta());
  
  histoRes2D["EtagenEl_vs_EtarecEl"]->Fill(genEl.Eta(),recEl.Eta());
  histoRes2D["EtagenEl_vs_EtagenEl-EtarecEl"]->Fill(genEl.Eta(),genEl.Eta()-recEl.Eta());
  histoRes2D["EgenEl_vs_EtarecEl"]->Fill(genEl.E(),recEl.Eta());
  histoRes2D["EgenEl_vs_EtagenEl-EtarecEl"]->Fill(genEl.E(),genEl.Eta()-recEl.Eta());
  
  histoRes2D["PhigenEl_vs_PhirecEl"]->Fill(genEl.Phi(),recEl.Phi());
  histoRes2D["EgenEl_vs_PhirecEl"]->Fill(genEl.E(),recEl.Phi());
  float DeltaPhi = ROOT::Math::VectorUtil::DeltaPhi(genEl,recEl);
  histoRes2D["PhigenEl_vs_PhigenEl-PhirecEl"]->Fill(genEl.Phi(),DeltaPhi);
  histoRes2D["EgenEl_vs_PhigenEl-PhirecEl"]->Fill(genEl.E(),DeltaPhi);
  
}

void ResolutionFunctions::writeHistograms()
{
  /// Define output file outside of function
  // Give it as argument?
  
  histoRes2D["Eparton_vs_Enonbjet"]->Write();
  histoRes2D["Eparton_vs_Ebjet"]->Write();
  histoRes2D["Thparton_vs_Thnonbjet"]->Write();
  histoRes2D["Thparton_vs_Thbjet"]->Write();
  histoRes2D["Etaparton_vs_Etanonbjet"]->Write();
  histoRes2D["Etaparton_vs_Etabjet"]->Write();
  histoRes2D["Phiparton_vs_Phinonbjet"]->Write();
  histoRes2D["Phiparton_vs_Phibjet"]->Write();
  histoRes2D["Eparton_vs_Thnonbjet"]->Write();
  histoRes2D["Eparton_vs_Thbjet"]->Write();
  histoRes2D["Eparton_vs_Etanonbjet"]->Write();
  histoRes2D["Eparton_vs_Etabjet"]->Write();
  histoRes2D["Eparton_vs_Phinonbjet"]->Write();
  histoRes2D["Eparton_vs_Phibjet"]->Write();
  
  histoRes2D["Eparton_vs_Eparton-Enonbjet"]->Write();
  histoRes2D["Eparton_vs_Eparton-Ebjet"]->Write();
  histoRes2D["Eparton_vs_Thparton-Thnonbjet"]->Write();
  histoRes2D["Eparton_vs_Thparton-Thbjet"]->Write();
  histoRes2D["Eparton_vs_Etaparton-Etanonbjet"]->Write();
  histoRes2D["Eparton_vs_Etaparton-Etabjet"]->Write();
  histoRes2D["Eparton_vs_Phiparton-Phinonbjet"]->Write();
  histoRes2D["Eparton_vs_Phiparton-Phibjet"]->Write();
  
  histoRes2D["Thparton_vs_Thparton-Thnonbjet"]->Write();
  histoRes2D["Thparton_vs_Thparton-Thbjet"]->Write();
  histoRes2D["Etaparton_vs_Etaparton-Etanonbjet"]->Write();
  histoRes2D["Thparton_vs_Thparton-Thbjet"]->Write();
  histoRes2D["Phiparton_vs_Phiparton-Phinonbjet"]->Write();
  histoRes2D["Phiparton_vs_Phiparton-Phibjet"]->Write();
  
  if (muon)
  {
    histoRes2D["InvPtgenMu_vs_InvPtrecMu"]->Write();
    histoRes2D["ThgenMu_vs_ThrecMu"]->Write();
    histoRes2D["EtagenMu_vs_EtarecMu"]->Write();
    histoRes2D["PhigenMu_vs_PhirecMu"]->Write();
    histoRes2D["InvPtgenMu_vs_ThrecMu"]->Write();
    histoRes2D["InvPtgenMu_vs_EtarecMu"]->Write();
    histoRes2D["InvPtgenMu_vs_PhirecMu"]->Write();
    
    histoRes2D["InvPtgenMu_vs_InvPtgenMu-InvPtrecMu"]->Write();
    histoRes2D["InvPtgenMu_vs_ThgenMu-ThrecMu"]->Write();
    histoRes2D["InvPtgenMu_vs_EtagenMu-EtarecMu"]->Write();
    histoRes2D["InvPtgenMu_vs_PhigenMu-PhirecMu"]->Write();
    
    histoRes2D["ThgenMu_vs_ThgenMu-ThrecMu"]->Write();
    histoRes2D["EtagenMu_vs_EtagenMu-EtarecMu"]->Write();
    histoRes2D["PhigenMu_vs_PhigenMu-PhirecMu"]->Write();
  }
  
  if (electron)
  {
    histoRes2D["EgenEl_vs_ErecEl"]->Write();
    histoRes2D["ThgenEl_vs_ThrecEl"]->Write();
    histoRes2D["EtagenEl_vs_EtarecEl"]->Write();
    histoRes2D["PhigenEl_vs_PhirecEl"]->Write();
    histoRes2D["EgenEl_vs_ThrecEl"]->Write();
    histoRes2D["EgenEl_vs_EtarecEl"]->Write();
    histoRes2D["EgenEl_vs_PhirecEl"]->Write();
    
    histoRes2D["EgenEl_vs_EgenEl-ErecEl"]->Write();
    histoRes2D["EgenEl_vs_ThgenEl-ThrecEl"]->Write();
    histoRes2D["EgenEl_vs_EtagenEl-EtarecEl"]->Write();
    histoRes2D["EgenEl_vs_PhigenEl-PhirecEl"]->Write();
    
    histoRes2D["ThgenEl_vs_ThgenEl-ThrecEl"]->Write();
    histoRes2D["EtagenEl_vs_EtagenEl-EtarecEl"]->Write();
    histoRes2D["PhigenEl_vs_PhigenEl-PhirecEl"]->Write();
  }
  
  std::cout << "ResolutionFunctions: Histograms written to file" << std::endl;
  makeFit();
}

void ResolutionFunctions::makeFit()
{
  std::cout << "                   Starting fit procedure... " << std::endl;
  
  
  for (int f = 0; f < nHistos; f++)
  {
    if ( f != 0 && f != 4 ) continue;
    
    if (! muon && (f == 8 || f == 9 || f == 10 || f == 11) ) continue;
    if (! electron && (f == 12 || f == 13 || f == 14 || f == 15) ) continue;
    
    if (electron) std::cout << "ResolutionFunctions::WriteOutputFiles -- WARNING: Electron fitting not yet implemented" << std::endl;
    if ( f == 2 || f == 6 || f == 10 || f == 14 ) continue;  // eta later
    
    std::cout << "  ***Current histogram:  " << histoNames[f] << "***" << std::endl;
    
    TH2F* histo=histoRes2D[(histoNames[f]).c_str()];
    if (getHistos)
      histo=fitHisto2D[(histoNames[f]).c_str()];
    
    
    int nBins = histo->GetXaxis()->GetNbins();
    std::cout << "nbins: " << nBins << std::endl;
    int nPar = 6;
    //int nPar = 5;
    
    /// Create one histogram for each function parameter -> 6 histograms for each 2D plot
    TH1D **hlist = new TH1D*[nPar];
    std::string parnames[nPar]={"a1","a2","a3","a4","a5","a6"};
    //std::string parnames[nPar]={"a1","a2","a3","a4","a5"};
    std::string name=""; std::string title="";
    //const TArrayD *bins = histo->GetXaxis()->GetXbins();
    for (int iPar = 0; iPar < nPar; iPar++)
    {
      name = std::string(histo->GetName())+ "_" + parnames[iPar];
      title = std::string(histo->GetName())+ ": Fitted value of " + parnames[iPar] ;
      hlist[iPar] = new TH1D(name.c_str(), title.c_str(), nBins, histo->GetXaxis()->GetXmin(), histo->GetXaxis()->GetXmax());
      hlist[iPar]->GetXaxis()->SetTitle(histo->GetXaxis()->GetTitle());
    }
    
    /// Loop on all bins in X, generate a projection along Y
    int cut = 0;  // require a minimum number of bins in the slice to be filled
    for (int xBin = 1; xBin < nBins+1; xBin++)
    {
      /// Make projection
      std::string projection_title = std::string(histo->GetName())+"_sliceXbin"+toStr(xBin);
      TH1D *hp = histo->ProjectionY(projection_title.c_str(), xBin, xBin, "e");
      if(xBin == nBins) hp = histo->ProjectionY(projection_title.c_str(), xBin, xBin+1, "e");  //include overflow in last bin
      if(xBin == 1) hp = histo->ProjectionY(projection_title.c_str(), xBin-1, xBin, "e");  //include underflow in first bin
      if (hp == 0) continue;
      float nEntries = float(hp->GetEntries());
      if (nEntries == 0 || nEntries < cut) {delete hp; continue;}
      
      
      /// Normalise histogram
      Double_t scale = 1./hp->Integral();
      hp->Scale(scale);
      
      std::cout << "Integral of the histo is " << hp->Integral() << std::endl;
      /// Declare the fit function
      //  ! Its range depends on the jet/lepton energy range (hence, the Y-axis)
      //TF1 *myfit = new TF1("myfit", "[2]*(TMath::Exp(-TMath::Power((x-[0]),2)/(2*TMath::Power([1],2)))+[5]*TMath::Exp(-TMath::Power((x-[3]),2)/(2*TMath::Power([4],2))))");
      //TF1 *myfit = new TF1("myfit", "(1./TMath::Sqrt(2*TMath::Pi()))*(1./([1]+[2]*[4]))*( TMath::Exp(-TMath::Power((x-[0]),2)/(2*TMath::Power([1],2))) + [2]*TMath::Exp(-TMath::Power((x-[3]),2)/(2*TMath::Power([4],2))) )");
      
      //TF1 *myfit2 = new TF1("myfit", "([5]/([1]+[2]*[4]))*( TMath::Exp(-TMath::Power((x-[0])/[1],2)/2.) + [2]*TMath::Exp(-TMath::Power((x-[3])/[4],2)/2.) )/sqrt(2.*TMath::Pi())");  // FOUT: norm factor, zie dblGaus
      
      
      TF1 *myfit = new TF1("myfit", dblGaus, -100, 100, nPar);
      
      //  Give names to the parameters
      myfit->SetParName(0,"a0");
      myfit->SetParName(1,"a1");
      myfit->SetParName(2,"a2");
      myfit->SetParName(3,"a3");
      myfit->SetParName(4,"a4");
      myfit->SetParName(5,"a5");
      //  Set initial values
      if ( f == 0 || f == 4 )  // energy (non-)b jet
      {
        //myfit->SetParameter(0, -2.5);    //central value of first, broad gaussian
        //myfit->SetParameter(1, 40.0);    //sigma value of first, broad gaussian
        //myfit->SetParameter(2, 63.0);    //constant value of first, broad gaussian
        //myfit->SetParameter(3, -0.0005); //central value of second, narrow gaussian
        //myfit->SetParameter(4, 6.0);     //sigma value of second, narrow gaussian
        //myfit->SetParameter(5, 4.1);     //constant value of second, narrow gaussian
        //myfit->SetParameter(0, hp->GetMean());   //central value of first, broad gaussian
        //myfit->SetParameter(1, hp->GetRMS()*1.3);  //sigma value of first, broad gaussian
        //myfit->SetParameter(2, 10.0); //constant value of second, narrow gaussian
        //myfit->SetParameter(3, hp->GetMean());  //central value of second, narrow gaussian
        //myfit->SetParameter(4, hp->GetRMS());   //sigma value of second, narrow gaussian
        
        // Mean around zero
        //myfit->SetParLimits(0,-10,10);
        myfit->SetParLimits(0, hp->GetMean() - hp->GetRMS()/2., hp->GetMean() + hp->GetRMS()/2.);
        myfit->SetParLimits(3, -30., 30.);
        // Restrict sigma to be positive
        myfit->SetParLimits(1, 5., 50.);
        myfit->SetParLimits(4, 10., 100.);
        
        /// Split for bins 1-2 and bins 3-4 ??
        //if ( xBin == 1 )
        //{
          //myfit->SetParameters(2.6, 7.6, 0.2, hp->GetMean(), hp->GetRMS()*2);
          //myfit->SetParameters(hp->GetMean(), hp->GetRMS()*2, 40.0, hp->GetMean(), hp->GetRMS());
          //myfit->SetParLimits(3, 2.6 - 7.6/2., 2.6 + 7.6/2.);
        //}
        if ( xBin == 1 || xBin == 2 )
        {
          myfit->SetParameters(hp->GetMean()-1., hp->GetRMS(), 0.3, 2., 14.4, 1.);
          //myfit->SetParLimits(0, hp->GetMean() - hp->GetRMS()/2., hp->GetMean() + hp->GetRMS()/2.);
          //myfit->SetParLimits(3, 2. - 14.4/2., 2. + 14.4/2.);
        }
        else if ( xBin == 3 )
        {
          myfit->SetParameters(hp->GetMean(), hp->GetRMS(), 0.9, 4.4, 23.0, 1.);
          myfit->SetParLimits(3, 4.4 - 23./2., 4.4 + 23./2.);
        }
        else if ( xBin == 4 )
        {
          myfit->SetParameters(hp->GetMean(), hp->GetRMS(), 2., 6.6, 36.5, 1.);
          myfit->SetParLimits(3, 6.6 - 36.5/2., 6.6 + 36.5/2.);
        }
        
      }
      else continue;  // test fitting on range
/*      else if ( f == 1 || f == 3 || f == 5 || f == 7 )  // theta & phi of jet (CHECK: also eta??)
      {
        //myfit->SetParameter(0, 0.0); 		//central value of first, broad gaussian
        //myfit->SetParameter(1, 0.3);    //sigma value of first, broad gaussian
        //myfit->SetParameter(2, 77.0);   //constant value of first, broad gaussian
        //myfit->SetParameter(3, 0.0004); //central value of second, narrow gaussian
        //myfit->SetParameter(4, 0.001);  //sigma value of second, narrow gaussian
        //myfit->SetParameter(5, 26.5);   //constant value of second, narrow gaussian
        myfit->SetParameter(0, hp->GetMean()); 		//central value of first, broad gaussian
        myfit->SetParameter(1, hp->GetRMS()*1.5);   //sigma value of first, broad gaussian
        myfit->SetParameter(2, 0.5);  //constant value of second, narrow gaussian
        myfit->SetParameter(3, hp->GetMean()); //central value of second, narrow gaussian
        myfit->SetParameter(4, hp->GetRMS());   //sigma value of second, narrow gaussian
        
        // Mean around zero
        myfit->SetParLimits(0,-0.06,0.06);
        myfit->SetParLimits(3,-0.06,0.06);
        // Restrict sigma to be positive
        myfit->SetParLimits(1,0,1);
        myfit->SetParLimits(4,0,0.2);
      }
      else if ( f == 8 )  // inv pt muon
      {
        //myfit->SetParameter(0, -0.008);  //central value of first, broad gaussian
        //myfit->SetParameter(1, 0.01);    //sigma value of first, broad gaussian
        //myfit->SetParameter(2, 24.0);    //constant value of first, broad gaussian
        //myfit->SetParameter(3, -0.0002); //central value of second, narrow gaussian
        //myfit->SetParameter(4, 0.00002); //sigma value of second, narrow gaussian
        //myfit->SetParameter(5, 19.0);    //constant value of second, narrow gaussian
        myfit->SetParameter(0, -0.008);  //central value of first, broad gaussian
        myfit->SetParameter(1, 0.002);   //sigma value of first, broad gaussian
        myfit->SetParameter(2, 100.0);   //constant value of second, narrow gaussian
        myfit->SetParameter(3, -0.0002); //central value of second, narrow gaussian
        myfit->SetParameter(4, 0.0002);  //sigma value of second, narrow gaussian
      }
      else if ( f == 9 || f == 11 )  // theta & phi of muon (CHECK: also eta??)
      {
        //myfit->SetParameter(0, 0.0); 		 //central value of first, broad gaussian
        //myfit->SetParameter(1, 0.01);    //sigma value of first, broad gaussian
        //myfit->SetParameter(2, 24.0); 	 //constant value of first, broad gaussian
        //myfit->SetParameter(3, 0.0);     //central value of second, narrow gaussian
        //myfit->SetParameter(4, 0.00001); //sigma value of second, narrow gaussian
        //myfit->SetParameter(5, 4.0);     //constant value of second, narrow gaussian
        myfit->SetParameter(0, 0.0); 		 //central value of first, broad gaussian
        myfit->SetParameter(1, 0.0005);  //sigma value of first, broad gaussian
        myfit->SetParameter(2, 100.0); 	 //constant value of second, narrow gaussian
        myfit->SetParameter(3, 0.0);     //central value of second, narrow gaussian
        myfit->SetParameter(4, 0.00001); //sigma value of second, narrow gaussian
      }
*/      
      //  Fit
      std::string func_title = std::string(histo->GetName())+"_sliceXbin"+toStr(xBin)+"_Fitted";
      myfit->SetName(func_title.c_str());
      hp->Fit(myfit, "R");
      int npFits = myfit->GetNumberFitPoints();
      if (npFits > nPar && npFits >= cut)
      {
        int binOn = xBin + 1/2;
        for (int iPar = 0; iPar < nPar; iPar++)
        {
          //std::cout << "histo->GetXaxis()->GetBinCenter(binOn): " << histo->GetXaxis()->GetBinCenter(binOn) << std::endl;
          //std::cout << "myfit->GetParameter("<<ipar<<") " << myfit->GetParameter(ipar) << std::endl;
          hlist[iPar]->Fill(histo->GetXaxis()->GetBinCenter(binOn),myfit->GetParameter(iPar)); // fill histogram for parameter i
          hlist[iPar]->SetBinError(histo->GetXaxis()->GetBinCenter(binOn),myfit->GetParError(iPar));
        }
        //hchi2->Fill(histo->GetXaxis()->GetBinCenter(binOn),myfit->GetChisquare()/(npfits-npar));
      }
      hp->Write();
      myfit->Write();
      
      std::cout << "Integral of the fit is " << myfit->Integral(-100,100,0) << std::endl;
      
      delete hp;
      delete myfit;
      
    }  // end loop bins
    
    
    /// Define the fitfunction for all parameters (6):
    //  ai = ai0 + ai1*Ep + ai2*sqrt(Ep)
    //  Its range depends on the parton energy range (hence, the X-axis)
    //TF1 *myfit2 = new TF1("myfit2", "[0]+[1]*x+[2]*sqrt(x)", histo->GetXaxis()->GetXmin(), histo->GetXaxis()->GetXmax());
    TF1 *myfit2 = new TF1("myfit2", "[0]+[1]*x", histo->GetXaxis()->GetXmin(), histo->GetXaxis()->GetXmax());
    // Give names to the parameters
    myfit2->SetParName(0,"ai0");
    myfit2->SetParName(1,"ai1");
    //myfit2->SetParName(2,"ai2");

    for (int iPar = 0; iPar < nPar; iPar++){
      int paramname = iPar+1;
      std::string func_title2 = std::string(histo->GetName())+"_a"+toStr(paramname)+"_Fitted";
      myfit2->SetName(func_title2.c_str());
      hlist[iPar]->Fit(myfit2);
      hlist[iPar]->Write();
      myfit2->Write();
    }
    
    delete [] hlist;
    delete myfit2;
    
  }  /// end loop on histos (f)
  
  
  //writeTable();
}

void ResolutionFunctions::makeFit(std::string inputFileName, std::string outputFileName)
{
  std::cout << "ResolutionFunctions::Getting histograms from file  " << inputFileName << std::endl;
  getHistos = true;
  
  TFile *fin = new TFile(inputFileName.c_str(),"read");
  fin->cd();
  
  for (int iHisto = 0; iHisto < nHistos; iHisto++)
  {
    if ( fin->GetListOfKeys()->Contains((histoNames[iHisto]).c_str()) )
    {
      fitHisto2D[histoNames[iHisto]] = (TH2F*) fin->Get((histoNames[iHisto]).c_str());
      if ( iHisto == 8 || iHisto == 9 || iHisto == 10 || iHisto == 11 ) muon = true;
      if ( iHisto == 12 || iHisto == 13 || iHisto == 14 || iHisto == 15) electron = true;
    }
  }
  
  
  TFile *foutRF = new TFile(outputFileName.c_str(), "RECREATE");
  foutRF->cd();
  
  for (int f = 0; f < nHistos; f++)
  {
    if (! muon && (f == 8 || f == 9 || f == 10 || f == 11) ) continue;
    if (! electron && (f == 12 || f == 13 || f == 14 || f == 15) ) continue;
    fitHisto2D[histoNames[f]]->Write();
  }
  
  makeFit();
  
  fin->Close();
  foutRF->Close();
  
  delete fin;
  delete foutRF;
}

void ResolutionFunctions::writeTable(std::string inputFileName)
{
  std::cout << "ResolutionFunctions::Writing table with parameters..." << std::endl;
  
  std::ofstream myResolutionFunctions;
  std::string myResolutionFunctions_TABLE = "ResolutionFunctions_TABLE.txt";
  myResolutionFunctions.open(myResolutionFunctions_TABLE.c_str());
  
  for(int f = 0; f < nHistos; f++)
  {
    TF1 *RF_par1,*RF_par2,*RF_par3,*RF_par4,*RF_par5,*RF_par6;
    std::string name1 = histoNames[f]+"_a1_Fitted";
    std::string name2 = histoNames[f]+"_a2_Fitted";
    std::string name3 = histoNames[f]+"_a3_Fitted";
    std::string name4 = histoNames[f]+"_a4_Fitted";
    std::string name5 = histoNames[f]+"_a5_Fitted";
    std::string name6 = histoNames[f]+"_a6_Fitted";
    
    TFile* rf = new TFile(inputFileName.c_str(),"READ");
    rf->cd();
    RF_par1 = (TF1*)rf->Get(name1.c_str());
    RF_par2 = (TF1*)rf->Get(name2.c_str());
    RF_par3 = (TF1*)rf->Get(name3.c_str());
    RF_par4 = (TF1*)rf->Get(name4.c_str());
    RF_par5 = (TF1*)rf->Get(name5.c_str());
    RF_par6 = (TF1*)rf->Get(name6.c_str());
    
    /// Write values to table
    if (RF_par1 && RF_par2 && RF_par3 && RF_par4 && RF_par5 && RF_par6)
    {
      myResolutionFunctions<< std::endl;
      myResolutionFunctions<<"\\begin{table}" << std::endl;
      myResolutionFunctions<<"\\caption{Parameters of the resolution function for the " << histoDescription[f]  << "}" << std::endl;
      myResolutionFunctions<<"\\label{tab:}" << std::endl;
      myResolutionFunctions<<"\\centering" << std::endl;
      myResolutionFunctions<<"\\begin{tabular}{c|ccc}" << std::endl;
      myResolutionFunctions<<"\\hline" << std::endl;
      myResolutionFunctions << "Type	& $a_{i0}$ & $a_{i1}$ ($\\sqrt{E}$) & $a_{i2}$ ($E$)" << "\\\\" << std::endl;
      myResolutionFunctions<<"\\hline" << std::endl;
      myResolutionFunctions << "Mean broad gaussian & $a_{10}$ = " << RF_par1->GetParameter(0) << "$\\pm$" << RF_par1->GetParError(0) << " & $a_{11}$ = " << RF_par1->GetParameter(1) << "$\\pm$" << RF_par1->GetParError(1) << " & $a_{12}$ = " << RF_par1->GetParameter(2) << "$\\pm$" << RF_par1->GetParError(2) << "\\\\" << std::endl;
      myResolutionFunctions << "Width broad gaussian & $a_{20}$ = " << RF_par2->GetParameter(0) << "$\\pm$" << RF_par2->GetParError(0) << " & $a_{21}$ = " << RF_par2->GetParameter(1) << "$\\pm$" << RF_par2->GetParError(1) << " & $a_{22}$ = " << RF_par2->GetParameter(2) << "$\\pm$" << RF_par2->GetParError(2) << "\\\\" << std::endl;
      myResolutionFunctions << "Constant broad gaussian & $a_{30}$ = " << RF_par3->GetParameter(0) << "$\\pm$" << RF_par3->GetParError(0) << " & $a_{31}$ = " << RF_par3->GetParameter(1) << "$\\pm$" << RF_par3->GetParError(1) << " & $a_{32}$ = " << RF_par3->GetParameter(2) << "$\\pm$" << RF_par3->GetParError(2) << "\\\\" << std::endl;
      myResolutionFunctions << "Mean narrow gaussian & $a_{40}$ = " << RF_par4->GetParameter(0) << "$\\pm$" << RF_par4->GetParError(0) << " & $a_{41}$ = " << RF_par4->GetParameter(1) << "$\\pm$" << RF_par4->GetParError(1) << " & $a_{42}$ = " << RF_par4->GetParameter(2) << "$\\pm$" << RF_par4->GetParError(2) << "\\\\" << std::endl;
      myResolutionFunctions << "Width narrow gaussian & $a_{50}$ = " << RF_par5->GetParameter(0) << "$\\pm$" << RF_par5->GetParError(0) << " & $a_{51}$ = " << RF_par5->GetParameter(1) << "$\\pm$" << RF_par5->GetParError(1) << " & $a_{52}$ = " << RF_par5->GetParameter(2) << "$\\pm$" << RF_par5->GetParError(2) << "\\\\" << std::endl;
      myResolutionFunctions << "Constant narrow gaussian & $a_{60}$ = " << RF_par6->GetParameter(0) << "$\\pm$" << RF_par6->GetParError(0) << " & $a_{61}$ = " << RF_par6->GetParameter(1) << "$\\pm$" << RF_par6->GetParError(1) << " & $a_{62}$ = " << RF_par6->GetParameter(2) << "$\\pm$" << RF_par6->GetParError(2) << "\\\\" << std::endl;
      myResolutionFunctions<<"\\hline" << std::endl;
      myResolutionFunctions<<"\\end{tabular}"<< std::endl;
      myResolutionFunctions<<"\\end{table}"<<std::endl;
      myResolutionFunctions<< std::endl;
    }
    rf->Close();
  }
  
  myResolutionFunctions.close();
  
}
